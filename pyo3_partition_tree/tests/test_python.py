import pickle

import pytest
import polars as pl

# Import the Python module generated by the Rust crate
from pyo3_partition_tree import PyPartitionTree


def make_simple_data(n: int = 8):
    X = pl.DataFrame(
        {
            "x1": list(range(n)),
            "x2": [v * 2 for v in range(n)],
        }
    )
    y = pl.DataFrame(
        {
            "y": [float(v % 3) for v in range(n)],
        }
    )
    X = X.cast(pl.Float64)
    y = y.cast(pl.Float64)
    return X, y


def test_predict_before_fit_raises():
    model = PyPartitionTree(
        max_iter=10,
        min_samples_split=2,
        min_samples_leaf_y=1,
        min_samples_leaf_x=1,
        min_samples_leaf=1,
        min_target_volume=0.0,
        max_depth=5,
        min_split_gain=0.0,
        boundaries_expansion_factor=0,
    )
    X, _ = make_simple_data()
    with pytest.raises(ValueError, match="Model is not fitted"):
        _ = model.predict(X)


def test_fit_and_predict_returns_dataframe_with_expected_shape_and_columns():
    X, y = make_simple_data(12)
    model = PyPartitionTree(
        max_iter=50,
        min_samples_split=2,
        min_samples_leaf_y=1,
        min_samples_leaf_x=1,
        min_samples_leaf=1,
        min_target_volume=0.0,
        max_depth=10,
        min_split_gain=0.0,
        boundaries_expansion_factor=0,
    )
    model.fit(X, y, None)
    preds = model.predict(X)
    # Should be a polars DataFrame
    assert isinstance(preds, pl.DataFrame)
    # Row count preserved
    assert preds.height == X.height


def test_fit_with_mismatched_row_counts_raises():
    X, y = make_simple_data(6)
    # Drop a row from y to mismatch
    y_bad = y.head(5)
    model = PyPartitionTree(
        max_iter=10,
        min_samples_split=2,
        min_samples_leaf_y=1,
        min_samples_leaf_x=1,
        min_samples_leaf=1,
        min_target_volume=0.0,
        max_depth=5,
        min_split_gain=0.0,
        boundaries_expansion_factor=0,
    )
    with pytest.raises(ValueError):
        model.fit(X, y_bad, None)


def test_pickle_unfitted_model():
    """Test that an unfitted PyPartitionTree can be pickled and unpickled."""
    model = PyPartitionTree(
        max_iter=10,
        min_samples_split=2,
        min_samples_leaf_y=1,
        min_samples_leaf_x=1,
        min_samples_leaf=1,
        min_target_volume=0.0,
        max_depth=5,
        min_split_gain=0.0,
        boundaries_expansion_factor=0,
    )
    # Pickle and unpickle
    pickled = pickle.dumps(model)
    unpickled_model = pickle.loads(pickled)

    # Verify the unpickled model is a PyPartitionTree
    assert isinstance(unpickled_model, PyPartitionTree)


def test_pickle_fitted_model():
    """Test that a fitted PyPartitionTree can be pickled and unpickled, and predictions match."""
    X, y = make_simple_data(12)
    model = PyPartitionTree(
        max_iter=50,
        min_samples_split=2,
        min_samples_leaf_y=1,
        min_samples_leaf_x=1,
        min_samples_leaf=1,
        min_target_volume=0.0,
        max_depth=10,
        min_split_gain=0.0,
        boundaries_expansion_factor=0,
    )
    model.fit(X, y, None)

    # Get predictions before pickling
    preds_before = model.predict(X)

    # Pickle and unpickle
    pickled = pickle.dumps(model)
    unpickled_model = pickle.loads(pickled)

    # Verify the unpickled model is a PyPartitionTree
    assert isinstance(unpickled_model, PyPartitionTree)

    # Verify predictions match after unpickling
    preds_after = unpickled_model.predict(X)
    assert preds_before.equals(preds_after)
